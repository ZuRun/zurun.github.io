<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[学习路线]]></title>
    <url>%2Fplan%2F</url>
    <content type="text"><![CDATA[2018-09-14 gradle学习, 多线程 学习视频 + 笔记]]></content>
  </entry>
  <entry>
    <title><![CDATA[gradle]]></title>
    <url>%2Fgradle-1%2F</url>
    <content type="text"><![CDATA[taskhello world在bulid.gradle文件中,添加task123task helloword &#123; doLast &#123; println 'hello grade !'&#125;&#125; 在当前目录运行gradle helloworld命令,会输出]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2Fgit%2F</url>
    <content type="text"><![CDATA[子仓库 git submodule添加子仓库1git submodule add &lt;仓库地址&gt; &lt;本地路径&gt; 示例1git submodule add git@github.com:ZuRun/json-online.git source/tools/json-online 添加成功后 父仓库根目录会增加了.gitmodule文件。 cat .gitmodule 123[submodule "source/tools/json-online"] path = source/tools/json-online url = git@github.com:ZuRun/json-online.git 父仓库的git 配置文件中会加入了submodule段。 cat .git/config 123submodule "source/tools/json-online"] url = git@github.com:ZuRun/json-online.git active = true .git/modules 下会有子模块的信息 参考链接 简书 新增 检出(checkout)克隆一个包含子仓库的仓库目录，并不会clone下子仓库的文件，只是会克隆下.gitmodule描述文件，需要进一步克隆子仓库文件。 12345// 初始化本地配置文件$ git submodule init// 检出父仓库列出的commit$ git submodule update 或者使用组合指令 1$ git submodule update --init --recursive 删除子仓库 删除submodule rm -rf .git/modules/xxxxx 删除gitconfig中关联信息的配置 12vim .git/config# 删除相关的[submodel] 删除.gitmodules中相关信息 vim .gitmodules Remove it from the cache without the “git” git rm --cached xxxxx 参考链接 stack overflow 删除子仓库,解决xxxxx already exists in the index]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[练习题]]></title>
    <url>%2Finterview%2Ftest%2F</url>
    <content type="text"><![CDATA[题目：有10个文件，每个文件有1000万行，文件内容的每一行为一个整型数字；需要，写一个程序，将所有数字排序，分为10个文件输出，如0号文件包含前1000万个数字，1号文件文件包含1千万-2千万之间的数字，依次类推。限制：如果使用java，-Xmx需要设置为32MB；其它语言也需限制内存为32MB。要求:正确输出 使用多线程加分编写时长：24 小时我主要使用了分而治之，多线程处理的方式。注意下同步即可。 作者：牛客网链接：https://zhuanlan.zhihu.com/p/43318646来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里P8架构师总结Java并发面试题]]></title>
    <url>%2Finterview%2Fthread%2F</url>
    <content type="text"><![CDATA[一、什么是线程？ 线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。 二、线程和进程有什么区别？ 线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。每个线程都拥有单独的栈内存用来存储本地数据。 三、如何在Java中实现线程？ 两种方式：java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程。 四、Java 关键字volatile 与 synchronized 作用与区别？ 1，volatile 它所修饰的变量不保留拷贝，直接访问主内存中的。 在Java内存模型中，有main memory，每个线程也有自己的memory (例如寄存器)。为了性能，一个线程会在自己的memory中保持要访问的变量的副本。这样就会出现同一个变 量在某个瞬间，在一个线程的memory中的值可能与另外一个线程memory中的值，或者main memory中的值不一致的情况。 一个变量声明为volatile，就意味着这个变量是随时会被其他线程修改的，因此不能将它cache在线程memory中。 2，synchronized 当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。 ①、当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。 ②、然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。 ③、尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。 ④、当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。 ⑤、以上规则对其它对象锁同样适用。 五、有哪些不同的线程生命周期？ 当我们在Java程序中新建一个线程时，它的状态是New。当我们调用线程的start()方法时，状态被改变为Runnable。线程调度器会为Runnable线程池中的线程分配CPU时间并且讲它们的状态改变为Running。其他的线程状态还有Waiting，Blocked 和Dead。 六、你对线程优先级的理解是什么？ 每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级。 七、什么是死锁(Deadlock)？如何分析和避免死锁？ 死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。 分析死锁，我们需要查看Java应用程序的线程转储。我们需要找出那些状态为BLOCKED的线程和他们等待的资源。每个资源都有一个唯一的id，用这个id我们可以找出哪些线程已经拥有了它的对象锁。 避免嵌套锁，只在需要的地方使用锁和避免无限期等待是避免死锁的通常办法。 八、什么是线程安全？Vector是一个线程安全类吗？ 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。 九、Java中如何停止一个线程？ Java提供了很丰富的API但没有为停止线程提供API。JDK 1.0本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了，之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当run() 或者 call() 方法执行完的时候线程会自动结束,如果要手动结束一个线程，你可以用volatile 布尔变量来退出run()方法的循环或者是取消任务来中断线程 十、什么是ThreadLocal? ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。 每个线程都会拥有他们自己的Thread变量，它们可以使用get()set()方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal实例通常是希望它们同线程状态关联起来是private static属性。 十一、Sleep()、suspend()和wait()之间有什么区别？ Thread.sleep()使当前线程在指定的时间处于“非运行”（Not Runnable）状态。线程一直持有对象的监视器。比如一个线程当前在一个同步块或同步方法中，其它线程不能进入该块或方法中。如果另一线程调用了interrupt()方法，它将唤醒那个“睡眠的”线程。 注意：sleep()是一个静态方法。这意味着只对当前线程有效，一个常见的错误是调用t.sleep()，（这里的t是一个不同于当前线程的线程）。即便是执行t.sleep()，也是当前线程进入睡眠，而不是t线程。t.suspend()是过时的方法，使用suspend()导致线程进入停滞状态，该线程会一直持有对象的监视器，suspend()容易引起死锁问题。 object.wait()使当前线程出于“不可运行”状态，和sleep()不同的是wait是object的方法而不是thread。调用object.wait()时，线程先要获取这个对象的对象锁，当前线程必须在锁对象保持同步，把当前线程添加到等待队列中，随后另一线程可以同步同一个对象锁来调用object.notify()，这样将唤醒原来等待中的线程，然后释放该锁。基本上wait()/notify()与sleep()/interrupt()类似，只是前者需要获取对象锁。 十二、什么是线程饿死，什么是活锁？ 当所有线程阻塞，或者由于需要的资源无效而不能处理，不存在非阻塞线程使资源可用。JavaAPI中线程活锁可能发生在以下情形： 1，当所有线程在程序中执行Object.wait(0)，参数为0的wait方法。程序将发生活锁直到在相应的对象上有线程调用Object.notify()或者Object.notifyAll()。 2，当所有线程卡在无限循环中。 十三、什么是Java Timer类？如何创建一个有特定时间间隔的任务？ java.util.Timer是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer类可以用安排一次性任务或者周期任务。 java.util.TimerTask是一个实现了Runnable接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用Timer去安排它的执行。 十四、Java中的同步集合与并发集合有什么区别？ 同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。 在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。 Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和 内部分区等现代技术提高了可扩展性。 十五、同步方法和同步块，哪个是更好的选择？ 同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。 十六、什么是线程池？ 为什么要使用它？ 创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。 为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。 从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。 十七、Java中invokeAndWait 和 invokeLater有什么区别？ 这两个方法是Swing API 提供给Java开发者用来从当前线程而不是事件派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用invokeAndWait()方法请求事件派发线程对组件进行相应更新。而invokeLater()方法是异步调用更新组件的。 十八、多线程中的忙循环是什么? 忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存。 在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。 十九、Java内存模型是什么？ Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。比如，先行发生关系确保了： 线程内的代码能够按先后顺序执行，这被称为程序次序规则。 对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。 前一个对volatile的写操作在后一个volatile的读操作之前，也叫volatile变量规则。 一个线程内的任何操作必需在这个线程的start()调用之后，也叫作线程启动规则。 一个线程的所有操作都会在线程终止之前，线程终止规则。 一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。 可传递性 二十、Java中interrupted 和isInterruptedd方法的区别？ interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。 非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态都有可能被其它线程调用中断来改变。 二十一、Java中的同步集合与并发集合有什么区别？ 同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。 不管是同步集合还是并发集合他们都支持线程安全，他们之间主要的区别体现在性能和可扩展性，还有他们如何实现的线程安全上。 同步HashMap, Hashtable, HashSet, Vector, ArrayList 相比他们并发的实现（ConcurrentHashMap, CopyOnWriteArrayList, CopyOnWriteHashSet）会慢得多。造成如此慢的主要原因是锁， 同步集合会把整个Map或List锁起来，而并发集合不会。并发集合实现线程安全是通过使用先进的和成熟的技术像锁剥离。 比如ConcurrentHashMap 会把整个Map 划分成几个片段，只对相关的几个片段上锁，同时允许多线程访问其他未上锁的片段。 同样的，CopyOnWriteArrayList 允许多个线程以非同步的方式读，当有线程写的时候它会将整个List复制一个副本给它。 如果在读多写少这种对并发集合有利的条件下使用并发集合，这会比使用同步集合更具有可伸缩性。 二十二、什么是线程池？ 为什么要使用它？ 创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池） 线程池的作用，就是在调用线程的时候初始化一定数量的线程，有线程过来的时候，先检测初始化的线程还有空的没有，没有就再看当前运行中的线程数是不是已经达到了最大数，如果没有，就新分配一个线程去处理。 就像餐馆中吃饭一样，从里面叫一个服务员出来；但如果已经达到了最大数，就相当于服务员已经用尽了，那没得办法，另外的线程就只有等了，直到有新的“服务员”为止。 线程池的优点就是可以管理线程，有一个高度中枢，这样程序才不会乱，保证系统不会因为大量的并发而因为资源不足挂掉。 二十三、Java中活锁和死锁有什么区别？ 活锁：一个线程通常会有会响应其他线程的活动。如果其他线程也会响应另一个线程的活动，那么就有可能发生活锁。同死锁一样，发生活锁的线程无法继续执行。然而线程并没有阻塞——他们在忙于响应对方无法恢复工作。这就相当于两个在走廊相遇的人：甲向他自己的左边靠想让乙过去，而乙向他的右边靠想让甲过去。可见他们阻塞了对方。甲向他的右边靠，而乙向他的左边靠，他们还是阻塞了对方。 死锁：两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候，死锁会让你的程序挂起无法完成任务。 二十四、如何避免死锁？ 死锁的发生必须满足以下四个条件： 互斥条件：一个资源每次只能被一个进程使用。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 两种种用于避免死锁的技术： 加锁顺序（线程按照一定的顺序加锁） 加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁） 二十五、notify()和notifyAll()有什么区别？ 1，notify()和notifyAll()都是Object对象用于通知处在等待该对象的线程的方法。 2，void notify(): 唤醒一个正在等待该对象的线程。 3，void notifyAll(): 唤醒所有正在等待该对象的线程。 两者的最大区别在于： notifyAll使所有原来在该对象上等待被notify的线程统统退出wait的状态，变成等待该对象上的锁，一旦该对象被解锁，他们就会去竞争。 notify他只是选择一个wait状态线程进行通知，并使它获得该对象上的锁，但不惊动其他同样在等待被该对象notify的线程们，当第一个线程运行完毕以后释放对象上的锁，此时如果该对象没有再次使用notify语句，即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，继续处在wait状态，直到这个对象发出一个notify或notifyAll，它们等待的是被notify或notifyAll，而不是锁。 二十六、什么是可重入锁（ReentrantLock）？ Java.util.concurrent.lock 中的 Lock 框架是锁定的一个抽象，它允许把锁定的实现作为Java 类，而不是作为语言的特性来实现。这就为Lock 的多种实现留下了空间，各种实现可能有不同的调度算法、性能特性或者锁定语义。 ReentrantLock 类实现了Lock ，它拥有与synchronized 相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。（换句话说，当许多线程都想访问共享资源时，JVM可以花更少的时候来调度线程，把更多时间用在执行线程上。） Reentrant 锁意味着什么呢？简单来说，它有一个与锁相关的获取计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，然后锁需要被释放两次才能获得真正释放。这模仿了synchronized 的语义；如果线程进入由线程已经拥有的监控器保护的synchronized 块，就允许线程继续进行，当线程退出第二个（或者后续）synchronized块的时候，不释放锁，只有线程退出它进入的监控器保护的第一个synchronized 块时，才释放锁。 二十七、读写锁可以用于什么应用场景？ 读写锁可以用于 “多读少写” 的场景，读写锁支持多个读操作并发执行，写操作只能由一个线程来操作 ReadWriteLock对向数据结构相对不频繁地写入，但是有多个任务要经常读取这个数据结构的这类情况进行了优化。ReadWriteLock使得你可以同时有多个读取者，只要它们都不试图写入即可。如果写锁已经被其他任务持有，那么任何读取者都不能访问，直至这个写锁被释放为止。 ReadWriteLock 对程序性能的提高主要受制于如下几个因素： 1，数据被读取的频率与被修改的频率相比较的结果。 2，读取和写入的时间 3，有多少线程竞争 4，是否在多处理机器上运行 原文链接: 知乎]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(三) java多线程 - 线程间的共享]]></title>
    <url>%2Fjava-thread-three%2F</url>
    <content type="text"><![CDATA[synchronized内置锁 可以确保原子性 对象锁，锁的是类的对象实例。 类锁 ，锁的是每个类的的Class对象，每个类的的Class对象在一个虚拟机中只有一个，所以类锁也只有一个。 spring框架下,javabean默认都是单例模式,synchronized方法锁可以保证生效 volatile 关键字 不保证原子性常用场景:只有一个线程写,多个线程读 ThreadLocal的使用线程间协作notify/notifyAllnotifynotifyAll 区别:notify只会通知第一个线程,]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(二) java多线程 - 线程常用方法和线程的状态]]></title>
    <url>%2Fjava-thread-two%2F</url>
    <content type="text"><![CDATA[线程只有5种状态。整个生命周期就是这几种状态的切换。 run()和start()区别 ： run方法就是普通对象的普通方法，只有调用了start()后，Java才会将线程对象和操作系统中实际的线程进行映射，再来执行run方法 123456789101112131415161718192021public class StartAndRun extents BaseTest&#123; public static class ThreadRun extends Thread &#123; @Override public void run()&#123; try &#123; TimeUnit.SECONDS.sleep(1); log(Thread.currentThread().getName()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args)&#123; Thread t=new ThreadRun(); t.setName("BeCalled"); // 输出"main" t.run(); // 输出"BeCalled",两次输出时间间隔1s t.start(); &#125;&#125; 线程守护 和主线程共死，finally不能保证一定执行 1234567891011121314151617181920212223242526public class DaemonThread &#123; private static class UseThread extends Thread &#123; @Override public void run() &#123; try &#123; while (!isInterrupted()) &#123; System.out.println(Thread.currentThread().getName() + " I am extends Thread."); &#125; System.out.println(Thread.currentThread().getName() + " interrupt flag is " + isInterrupted()); &#125; finally &#123; System.out.println("...........finally"); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; UseThread useThread = new UseThread(); // 设置为守护线程,需要再start()方法之前 useThread.setDaemon(true); useThread.start(); Thread.sleep(5); // useThread.interrupt(); &#125;&#125; 设置了守护线程后输出为:12345Thread-0 I am extends Thread.Thread-0 I am extends Thread.Thread-0 I am extends Thread.Thread-0 I am extends Thread.Process finished with exit code 0 如果不设置守护进程,当主线程执行完毕后,userThread还会继续执行,直到执行完毕设置了守护进程后,子线程会中断,即使有final方法块,也不一定执行]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(一) java多线程 - 认识Java里的线程]]></title>
    <url>%2Fjava-thread-one%2F</url>
    <content type="text"><![CDATA[多线程可以充分利用cpu的资源、加快用户响应的时间，程序模块化，异步化但是使用不当,也容易出现问题 线程共享资源，存在冲突； 容易导致死锁； 启用太多的线程，就有搞垮机器的可能 新启线程方式 实现Runnable接口(常用) 123456789101112131415161718public class NewThread &#123; /**实现Runnable接口*/ private static class UseRun implements Runnable &#123; @Override public void run() &#123; System.out.println("I am implements Runnable"); &#125; &#125; public static void main(String[] args) &#123; UseRun useRun = new UseRun(); new Thread(useRun).start(); // java lambda方式 new Thread(() -&gt; System.out.println("In Java8, Lambda expression rocks !!")) .start(); &#125;&#125; 实现Callable接口,允许有返回值 继承Thread类 不推荐使用此方式,java是单继承的 线程停止 java线程是协作式 如果优雅的响应中断线程推荐使用以下方式: interrupt() 方法 中断一个线程,并不会强制中断,告诉线程可以中断(中断标志位会设置为true) static方法interrupted() 判断当前线程是否处于终端状态,同时中断标志位改为false 1.可以通过isInterrupted()与静态方法interrupted() 判断当前线程是否处于中断状态2.如果用自定义变量来标示是否中断的话,当while循环中在调用阻塞方法时,即使将中断标示置为true,也不会立即响应.(线程被阻塞了) interrupt() 方法1234567891011121314public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread(() -&gt; &#123; String threadName = Thread.currentThread().getName(); System.out.println("Thread is start"); while (!Thread.currentThread().isInterrupted()) &#123; System.out.println(threadName + " is run"); &#125; System.out.println(threadName + " interrupt flag is " + Thread.currentThread().isInterrupted()); &#125;, "endThreadA"); thread.start(); Thread.sleep(1000L); thread.interrupt();&#125; 自定义变量标示中断(不推荐)1234567891011121314151617181920212223242526272829303132333435363738394041/*** 自定义变量标示是否中断线程*/public static class CustomizedInterruptThread extends Thread &#123; /** * 标示是否中断线程 */ private volatile boolean cancel = false; @Override public void interrupt() &#123; this.cancel = true; &#125; public CustomizedInterruptThread(String threadName) &#123; super(threadName); &#125; @Override public void run() &#123; String threadName = Thread.currentThread().getName(); while (!cancel) &#123; try &#123; Thread.sleep(2000L); log(threadName + " is run,flag is " + cancel); &#125; catch (InterruptedException e) &#123; log(threadName + " throw InterruptedException,flag is " + cancel); e.printStackTrace(); &#125; &#125; log(threadName + " cancel flag is " + cancel); &#125;&#125;public static void main(String[] args) throws InterruptedException &#123; Thread flagInterruptThread = new CustomizedInterruptThread("FlagInterruptThread"); flagInterruptThread.start(); Thread.sleep(100L); flagInterruptThread.interrupt(); System.out.println("Thread interrupt time:" + System.currentTimeMillis());&#125; 执行后输出1232018-08-24 00:22:08:940 - giving instructions to interrupt 2018-08-24 00:22:10:840 - FlagInterruptThread is run,flag is true2018-08-24 00:22:10:840 - FlagInterruptThread cancel flag is true 可以发现,发出中断指令后,等待了1900ms线程才终止 InterruptedException异常 java中所有阻塞方法都会抛出InterruptedException异常当子线程在休眠的时候,调用中断方法,会抛出InterruptedException 方法里如果抛出InterruptedException异常,会将interrupt标志位复位为false,如果需要让线程继续中断的话,需要在catch中再次执行interrupt()方法 123456789101112131415161718192021222324252627282930/*** interrupt()方法标示 中断*/public static class InterruptThread implements Runnable &#123; @Override public void run() &#123; String threadName = Thread.currentThread().getName(); while (!Thread.currentThread().isInterrupted()) &#123; try &#123; Thread.sleep(1000L); LogUtils.log(threadName + " is run,flag is " + Thread.currentThread().isInterrupted()); &#125; catch (InterruptedException e) &#123; // 根据业务需要,决定是否重新标识中断标识 Thread.currentThread().interrupt(); LogUtils.log(threadName + " throw InterruptedException,flag is " + Thread.currentThread().isInterrupted()); e.printStackTrace(); &#125; &#125; LogUtils.log(threadName + " cancel flag is " + Thread.currentThread().isInterrupted()); &#125;&#125;public static void main(String[] args) throws InterruptedException &#123; Thread t = new Thread(new InterruptThread(),"InterruptThread"); t.start(); Thread.sleep(100L); // 当子线程在休眠的时候,调用中断方法,会抛出InterruptedException t.interrupt(); LogUtils.log("giving instructions to interrupt2 ");&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iterm2]]></title>
    <url>%2Fmac%2Fiterm2%2F</url>
    <content type="text"><![CDATA[记住密码,自动登录 iterm2登录需要输入密码的服务器,不能记住密码自动登录.现通过Linux expect 的脚本实现自动登录 expect脚本 常用参数 [lindex $argv 0] 执行脚本的参数 示例 12345678910111213141516171819202122## 跳板机脚本#!/usr/bin/expectset TERMSERV 101.200.191.81set USER huizhang3set PASSWORD 0&gt;9HdDJ&#125;UXs|nf2^set UATUN 内网服务器用户名set UATPWD 内网服务器密码# 登录跳板机spawn ssh -p 2112 $USER@$TERMSERVexpect &#123; &quot;yes/no&quot; &#123;send &quot;yes\r&quot;;exp_continue;&#125; &quot;*password:*&quot; &#123; send &quot;$PASSWORD\r&quot; &#125; &#125;# 登录内网expect &quot;Welcome&quot; &#123;send &quot;ssh -p 8025 vmuser@127.0.0.1\r&quot;&#125;expect &#123; &quot;yes/no&quot; &#123;send &quot;yes\r&quot;;exp_continue;&#125; &quot;*password:*&quot; &#123; send &quot;BgL#fgBYE&amp;7BL!LT\r&quot; &#125; &#125;interact 参考链接 执行权限脚本的可执行权限1chmod -R a+x /Users/zurun/iflytek/shell/iterm2/common]]></content>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next主题个性化配置]]></title>
    <url>%2Fhexo-next-theme-personalized-tutorial%2F</url>
    <content type="text"><![CDATA[文章字数统计与阅读时间Usagehexo‘s _config.yml文件 增加12345symbols_count_time: symbols: true time: true total_symbols: true total_time: true Next主题_config.yml配置 ,搜索symbols_count_time 参考链接]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[评论系统valine]]></title>
    <url>%2Fvaline-system-valine%2F</url>
    <content type="text"><![CDATA[valine - 一款快速、简洁且高效的无后端评论系统。 特性 快速 安全 Emoji 😉 无后端实现 MarkDown 全语法支持 轻量易用(~15kb gzipped) 文章阅读量统计 v1.2.0+ 准备工作LeanCloud存储评论内容需要保存到LeanCloud,注册账号并创建应用 生效next主题next主题新版的主题配置中添加此配置了 _config.yml中搜索valine,配置上LeanCloud的AppId和AppKey其他配合自行修改即可 配置1234567891011valine: enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version. appid: # your leancloud application appid appkey: # your leancloud application appkey notify: true # mail notifier , https://github.com/xCss/Valine/wiki verify: true # Verification code placeholder: Just go go # comment box placeholder avatar: mp # gravatar style 头像 guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: true # 评论系统 leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors' for counter compatibility. Article reading statistic https://valine.js.org/visitor.html]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>valine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-plugins]]></title>
    <url>%2Fhexo%2Fhexo-plugins%2F</url>
    <content type="text"><![CDATA[UML根据markdown,生成uml图 详见:github:hexo-filter-plantuml install1npm install --save hexo-filter-plantuml eg. markdown详细用法:官网http://plantuml.com/markdown 在线预览]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown]]></title>
    <url>%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[任务清单1234* [x] 勾选1- [x] 勾选2* [ ] 未勾选1- [ ] 未勾选2 勾选1 勾选2 未勾选1 未勾选2 缩进&amp;ensp; &amp;ensp; UML图见plant-uml]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转)谈技术建议书编写]]></title>
    <url>%2Ftechnical-proposal%2F</url>
    <content type="text"><![CDATA[通读标书了解项目范围和目标&ensp; &ensp;当拿到标书的电子档材料候，首先应该通读整个标书，特别是里面的项目背景，目标，项目建设范围，详细的技术规范书说明，如果有详细打分表的还需要详细阅读技术打分表，了解项目技术打分的重点。&ensp; &ensp;一般拿到标后，甲方都会安排一次标前答疑，对于应标团队要高度重视标前答疑工作，准备好相应的问题。其中问题重点还是应该是项目建设范围和实施范围，项目的关于技术约束，产品选型要求，同时也需要对标书中本身出现的前后不一致内容进行答疑。这些都是需要甲方进一步进行澄清的内容。当然如果应标团队有些关键技术不满足，或者觉得甲方设置不合理也可以标前答疑提出来，甲方认为建议合理也可以进行修正。 &ensp; &ensp;界定清楚项目范围是应标前最重要的事情，范围的不确定将导致后面建设和实施工作量出现成倍的差异。举例来说一个软件项目建设完成后，究竟是实施5个子公司还是30个子公司，这将带来工作量和项目费用的巨大变化。因此务必重视第一阶段的范围界定，不能有任何模糊的地方。 &ensp; &ensp;另外一个重要工作就是技术评分规则的详细分析，要明白你写的技术建议书更多要围绕技术评分规则展开，即技术评分项都能够在你的建议书中很明显的找到，方便专家评委进行阅读和打分。因此对于比较大的标，我们在制作标书的时候还会准备一个评标导引文件，告诉评委技术评分点内容在标书里面的哪个章节等。 搭建技术建议书目录框架结构&ensp; &ensp;在对投标项目的目标和范围都明确后，就可以开始搭建技术建议书的目录框架结构。注意有些技术标发出来本身就提供了技术建议书的目录结构要求，那么遵从甲方的要求就可以了，但是你还是可以在不破坏甲方目录结构的情况下在最后增加一个附录来编写你认为有必要说明的关键问题和公司技术亮点等。 &ensp; &ensp;如果技术标本身没有限定项目的目录结构，那么就需要我们自己搭建。那么首先我们来看对于软件类项目应标的时候技术建议书的一个通用大框架： 项目概述（包括项目背景，目标，项目建设范围等） 需求分析（重点是你对项目目标范围的理解，对关键建设内容逐个分析） 项目整体建设方案（总体架构，技术架构，功能架构-按建设范围逐层分解描述，部署方案，安全方案） 项目实施方案（实施方法论，团队组织，人员，进度计划等） 项目管理方案（标准项目管理方法论上修订） 项目案例说明（客户，项目规模，建设内容，实施周期，人员等） 下面我们以上内容的关键点做一个说明： &ensp; &ensp;项目概述的内容基本从甲方提供的标书材料里面拷贝，不用去加工。重点是需求分析部分，需要分析部门说明你对项目建设目标内容的理解，你大概准备采用什么产品，技术来实现需求等。需求分析是衔接项目建设目标范围和项目整体解决方案间的桥梁。否则给甲方看文档的感觉就是两者之间脱节，不清楚你是根据目标如果就给出了一个整体方案和架构，而这些都需要在需求分析部分说明清楚。 &ensp; &ensp;最难的还是项目整体建设方案章节，你需要拿出一个总体架构图，这个架构图覆盖本期项目建设范围，同时体现完整的逻辑和分层。然后对这个总架构图进行分解，即成了后续各个子系统建设方案的详细描述。这个地方如何进行抽象整合，如何揉是最难的点。 &ensp; &ensp;同时整体方案也包括了部署架构，非功能性架构（安全，性能，管控，部署和网络）各方面的内容，这些都需要在整体解决方案中进行详细描述。所以不要简单的以为整体解决方案仅仅是功能架构的描述。如果安装企业架构的思路，那么整体解决方案应该分为： &ensp; &ensp;总体架构描述（业务架构，应用架构，数据架构，集成架构，技术架构（非功能性架构全在这））,然后业务架构可以按流程线或业务域进行分解描述，应用架构按子系统分解展开详细描述。这样整体解决方案就形成了一个完整统一，紧凑的文档结构模式。 建议书内容编写分工，架构设计&ensp; &ensp;对于一个大项目的技术建议书编写，往往在搭建完整体目录结构后可以开始考虑进行内容分解，分解后安排到不同的人员去编写。比如不同的子系统方案安排到不同的人编写，对于标准和业务无关的技术方案安排到技术架构，对于IT基础设施和部署架构安排到工程人员编写。 &ensp; &ensp;对于这种大的技术建议书，统筹的人最重要，一个大的售前项目应标和技术建议书编写本身就是一个项目，需要有严格的项目计划和进度控制，啥时候完成哪部分的编写，啥时候整合，啥时候进行内容评审和修订，啥时候安排打印等都需要有明确的时间安排。否则很容易出现在交标前手忙脚乱的情况。 在内容编写的时候首先又要分出两部分内容： 哪些是原来建议书就写过的的标准化的内容，不用修改的? 哪些是需要根据本次应标项目有针对性的调整的? &ensp; &ensp;也正是这个原因，如果经常做售前项目应标，不是简单的积累已有的技术方案和技术建议书，而是应该对产品功能说明，项目管理方法论，团队人员简历，运维和售后规范流程，项目案例等都准备独立的可复用的标准化，模块化文件。到了真正应标的时候，根据需要对这些内容进行组装和整合。 &ensp; &ensp;而实际我们要做的，对于整体解决方案里面就是整体架构设计，通过整体架构设计图和内容说明将前面的需求分析和后面的模块化产品说明串接起来形成一个整体。其次，就是实施方面，这个涉及到需要根据项目本期的业务目标和需求排项目的项目进度计划，安排项目人员等，这些也需要花较多时间准备。 建议书内容整合和检查&ensp; &ensp;最后一个阶段就是对建议书内容进行整合，整合完成后进行目录结构，字体，行距，错别字等基础的合规性检查。其次是按照项目目标范围要求，进行内容的检查，确认没有关键内容遗漏。最后就是基于项目技术打分表，进一步确认每个技术打分项都在提交的技术建议书里面有明确的描述，同时完成技术评分指引表，说明具体的内容位置。 原文链接: https://steemit.com/it/@tigernotiger/beu5g作者: tigernotiger]]></content>
      <categories>
        <category>docs</category>
      </categories>
      <tags>
        <tag>docs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(一)hexo搭建]]></title>
    <url>%2Fhexo-build%2F</url>
    <content type="text"><![CDATA[nodeJs环境 安装node 从官网地址下载稳定版,并安装 环境配置 如果node -v 不显示版本号,则需要配置环境变量 配置全局环境变量 vim .bash_profile 1PATH=$PATH:/usr/local/bin/ 安装使用 npm 安装 Hexo。 1sudo npm install -g hexo-cli 使用cd到路径后1hexo init 建立hexo项目,即可开始使用]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[针对java8的Optional进行增强 (OptionalPlus)]]></title>
    <url>%2Fjava8-optional-plus%2F</url>
    <content type="text"><![CDATA[&ensp; &ensp; 网上关于optional用法的文章有一大堆了,但都只是简单的说了下如何去使用,感觉和实际使用中情况差的蛮大的.&ensp; &ensp; 在最初尝试使用optional的时候感觉很迷茫,感觉这个东西作用不大啊,看了遍源码也无法理解意义何在.&ensp; &ensp; 然后强迫自己多使用了几次后,发现这个功能还是挺好用的,也慢慢理解了作者的意图.&ensp; &ensp; 但随着使用次数增多,发现optional在很多场景下根本无法满足自己的需要,写了一半只能删掉用常规的写法.&ensp; &ensp; 所以为了满足自己的需求,写了OptionalPlus来治愈自己的强迫症 optional简洁 optional-plus不同场景示例 判断对象是否为空,为空执行A操作,不为空执行B操作12345678910111213141516171819public P2cMessageData example()&#123; P2cMessageData data = new P2cMessageData(); OptionalPlus.ofNullable(getTokenAndSessionByDeviceId(data.getDeviceId())) .filter(DebuggingDeviceTokenAndSessionData::getIsReady) .filter(deviceTokenAndSessionData -&gt; deviceTokenAndSessionData.getSessionInfo() != null) .ifNotPresent(() -&gt; &#123; logger.info("无密钥,尝试重新获取密钥!") data.setDecryptedData("无密钥,尝试重新获取密钥!"); ServerConnectGlobal.refreshTokenAndSession(data.getDeviceId()); &#125;) .ifPresent(deviceTokenAndSessionData -&gt; &#123; String sessionKey = deviceTokenAndSessionData.getSessionInfo().getSessionKey(); String devicePinCipher = deviceTokenAndSessionData.getSessionInfo().getDevicePinCipher(); data.setDecryptedData(AesUtils.decrypt(data.getMessage().getData(), sessionKey, devicePinCipher)); &#125;); return data;&#125; 完整代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public final class OptionalPlus&lt;T&gt; &#123; private final Optional&lt;T&gt; optional; private OptionalPlus(Optional&lt;T&gt; optional) &#123; this.optional = Objects.requireNonNull(optional); &#125; public static &lt;T&gt; OptionalPlus&lt;T&gt; empty() &#123; return new OptionalPlus&lt;&gt;(Optional.empty()); &#125; public static &lt;T&gt; OptionalPlus&lt;T&gt; of(T t) &#123; return new OptionalPlus&lt;&gt;(Optional.of(t)); &#125; public static &lt;T&gt; OptionalPlus&lt;T&gt; ofNullable(T t) &#123; return t == null ? empty() : of(t); &#125; public static &lt;T&gt; OptionalPlus&lt;T&gt; ofNullable(Optional&lt;T&gt; t) &#123; return t == null ? empty() : new OptionalPlus&lt;&gt;(t); &#125; /** * 获取optional对象,只保证optional不为null * * @return */ public Optional&lt;T&gt; getOptional() &#123; if (optional == null) &#123; throw new NoSuchElementException("No value present"); &#125; return optional; &#125; public T get() &#123; return getOptional().get(); &#125; public boolean isPresent() &#123; return optional.isPresent(); &#125; /** * 如果不为null,执行回调,并返回this * * @param consumer * @return */ public OptionalPlus&lt;T&gt; ifPresent(Consumer&lt;? super T&gt; consumer) &#123; optional.ifPresent(consumer); return this; &#125; public OptionalPlus&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) &#123; return optional.filter(predicate).isPresent() ? this : empty(); &#125; public &lt;U&gt; OptionalPlus&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) &#123; return OptionalPlus.ofNullable(optional.map(mapper)); &#125; public T orElse(T other) &#123; return optional.orElse(other); &#125; public T orElseGet(Supplier&lt;? extends T&gt; other) &#123; return optional.orElseGet(other); &#125; public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X &#123; return optional.orElseThrow(exceptionSupplier); &#125; /** * 如果对象为null,执行回调,并返回this * * @param noArgsFunction * @return */ public OptionalPlus&lt;T&gt; ifNotPresent(NoArgsFunction noArgsFunction) &#123; if (!isPresent()) &#123; noArgsFunction.todo(); &#125; return this; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) &#123; return true; &#125; if (!(obj instanceof OptionalPlus)) &#123; return false; &#125; OptionalPlus&lt;?&gt; other = (OptionalPlus&lt;?&gt;) obj; return Objects.equals(optional, other.getOptional()); &#125; @Override public int hashCode() &#123; return Objects.hashCode(optional); &#125; @Override public String toString() &#123; return optional != null ? optional.toString() : "Optional.empty"; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
        <tag>optional</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索seo等]]></title>
    <url>%2Fhexo-sitemap%2F</url>
    <content type="text"><![CDATA[收录确认网站是否被收录直接在百度/谷歌搜索 site:blog.zull.cn 提交网站未被收录,会出现提交地址,点击进入.这里用html验证就好了 下载验证html 根据提示,下载验证html,并保存到source根目录 有一个比较坑的地方,source下文件会被模板改变 所以需要再文件头上增加 123 ---layout: false--- 站点地图 插件12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 验证hexo g检查public目录下的sitemap.xml和baidusitemap.xml 部署seokeywordshttps://segmentfault.com/a/1190000007477815在博客根目录下找到_config.yml文件，在所示地方添加keywords: 关键字1,关键字2,关键字3…，采用英文逗号隔开，注意keywords与关键词之间的空格12345678# Sitetitle: 站点标题subtitle: 站点副标题description: 站点描述author: 站点作者language: zh-CNtimezone:keywords: 前端博客,JavaScript,html5,css3,Jquery,NodeJs,Ubuntu（#博客关键字）]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8常用新特性]]></title>
    <url>%2Fjava8-new-features%2F</url>
    <content type="text"><![CDATA[函数式编程-lambda 本质上是匿名函数 语法更简洁 12345678910// Java 8之前：new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("Before Java8, too much code for too little to do"); &#125;&#125;).start();//Java 8方式：new Thread( () -&gt; System.out.println("In Java8, Lambda expression rocks !!") ).start(); 格式 无返回值 1234(int params) -&gt; &#123;your Code&#125;// 一个参数的,可以不加小括号;代码块如果只有一行,大括号也不需要;参数类型不需要加params -&gt; your Code(params,params) -&gt; your Code 有返回值 123456params -&gt; your Code(params,params) -&gt; &#123; your Code; return xxx; &#125; 函数接口 常用接口 Function&lt;T, R&gt; Consumer Supplier Predicate FunctionalInterface注解 自定义接口 捕获外部变量 捕获实例或静态变量是没有限制的(可认为是通过 final 类型的局部变量 this 来引用前两者) 捕获的局部变量必须显式的声明为 final 或实际效果的的 final 类型(编译器推断变量的“常量性”（finality）) 例子见com.iflytek.vbox.skill.platform.service.VboxProvinceSkillManagementService#provinceManagement 集合中遍历、排序等 1234List&lt;String&gt; list = Arrays.asList("1", "2", "3", "4", "5", "6");list.listIterator().forEachRemaining(s -&gt; System.out.println(s));list.listIterator().forEachRemaining(System.out::println);list.forEach(System.out::println); 双冒号 检查异常 接口默认方法- 继承 - optional为了避免空指针异常,详见 OptionalPlus 简书例子]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo技巧]]></title>
    <url>%2Fhexo-skill%2F</url>
    <content type="text"><![CDATA[官方中文文档 介绍source文件下为markdown文章,其中 _drafts 为私密文章 _posts 为正常的文章 目录下可以自行建立文件夹 博客配置站点配置文件_config.yml 说明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137# Hexo Configuration Hexo配置文件## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# 网站信息#标题title: 那年四月#副标题subtitle: 小桥 · 流水 · 人家#网站描述description: 吃饭睡觉打豆豆(づ｡◕‿‿◕｡)づ#作者昵称author: 吃兔子的小萝卜#网站语言，设置简体汉语language: zh-Hans#时区，默认电脑时区#timezone: timezone: Asia/Shanghai# 网址设置#如果网站是放在子目录中，将url设置成'http://yoursite.com/child'，将root设置成'/child/'## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'#网址url: http://wangyiting.win#网站根目录。如果网站是放在子目录中，将root设置成'子目录名'root: /#文章链接地址格式 。即文章存放的目录。permalink: :year/:month/:day/:title/permalink_defaults:# 目录设置#资源文件夹，放在里面的文件会上传到github中source_dir: source#公共文件夹，存放生成的静态文件public_dir: public#标签文件夹，默认是tags。实际存放在source/tags中。tag_dir: tags#rss_dir: rss#档案文件夹，默认是archives。archive_dir: archives#分类文件夹，默认是categories。实际存放在source/categories中。category_dir: categories#代码文件夹，默认是downloads/codecode_dir: downloads/code#国际化文件夹，默认跟language相同i18n_dir: :lang#不需要渲染的文件夹或文件夹,放在[]中# 例如百度和google的站长验证文件，不能渲染，否则会改变内容，不能验证过skip_render: # 写作文章选项# 新建博文（帖子）的默认名称# File name of new postsnew_post_name: :title.md #默认布局模板是post，而不是draft和pagedefault_layout: post#是否将标题转换成标题形式（首字母大写）titlecase: false # Transform title into titlecase#在新标签页面中打开网页external_link: true # Open external links in new tabfilename_case: 0#是否渲染草稿render_drafts: false#启动 Asset 文件夹post_asset_folder: false#把链接改为与根目录的相对位址relative_link: false#显示未来的文章future: true#代码块的设置highlight: enable: true # 使用代码高亮 line_number: true # 显示行号 auto_detect: true # 自动检测语言 tab_replace:# 分类和标签# 默认分类default_category: uncategorized#分类别名category_map:#标签别名tag_map:# 日期和时间格式#Hexo 使用 Moment.js 来解析和显示时间。## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# 分页配置#每页显示的文章量 per_page: 8#分页路径，在public中可以看到#pagination_dir: page# Extensions 拓展插件配置## Plugins: https://hexo.io/plugins/plugins: baidusitemap: path: baidusitemap.xml#search 站内搜索# 需要安装插件：# npm install hexo-generator-search --save# npm install hexo-generator-searchdb --savesearch: path: search.xml field: post format: html limit: 10000# 主题配置## Themes: https://hexo.io/themes/#theme: false #禁用主题#theme: landscapetheme: next# Deployment 部署配置## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: # 部署到github，取消注释，可同时部署 # github: git@github.com:erbiduo/wyt.github.io.git,master # 部署到coding.net coding: git@git.coding.net:erduo/blog.git,master 新增私密文章1hexo new draft &quot;私密文章标题1&quot; 会在source/_drafts目录下生成md文件 如果你希望强行预览草稿，更改配置文件： render_drafts: true 或者，如下方式启动server： hexo server --drafts 预览的时候不全部显示所有内容md中加上&lt;!--more--&gt; 预览的时候会显示更多按钮 github绑定自己的域名注意: 需要再source文件下新增名为CNAME的文件,内容为域名]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
