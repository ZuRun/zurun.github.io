<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[markdown]]></title>
    <url>%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[缩进&amp;ensp; &amp;ensp;]]></content>
  </entry>
  <entry>
    <title><![CDATA[(转)谈技术建议书编写]]></title>
    <url>%2Ftechnical-proposal%2F</url>
    <content type="text"><![CDATA[通读标书了解项目范围和目标&ensp; &ensp;当拿到标书的电子档材料候，首先应该通读整个标书，特别是里面的项目背景，目标，项目建设范围，详细的技术规范书说明，如果有详细打分表的还需要详细阅读技术打分表，了解项目技术打分的重点。&ensp; &ensp;一般拿到标后，甲方都会安排一次标前答疑，对于应标团队要高度重视标前答疑工作，准备好相应的问题。其中问题重点还是应该是项目建设范围和实施范围，项目的关于技术约束，产品选型要求，同时也需要对标书中本身出现的前后不一致内容进行答疑。这些都是需要甲方进一步进行澄清的内容。当然如果应标团队有些关键技术不满足，或者觉得甲方设置不合理也可以标前答疑提出来，甲方认为建议合理也可以进行修正。 &ensp; &ensp;界定清楚项目范围是应标前最重要的事情，范围的不确定将导致后面建设和实施工作量出现成倍的差异。举例来说一个软件项目建设完成后，究竟是实施5个子公司还是30个子公司，这将带来工作量和项目费用的巨大变化。因此务必重视第一阶段的范围界定，不能有任何模糊的地方。 &ensp; &ensp;另外一个重要工作就是技术评分规则的详细分析，要明白你写的技术建议书更多要围绕技术评分规则展开，即技术评分项都能够在你的建议书中很明显的找到，方便专家评委进行阅读和打分。因此对于比较大的标，我们在制作标书的时候还会准备一个评标导引文件，告诉评委技术评分点内容在标书里面的哪个章节等。 搭建技术建议书目录框架结构&ensp; &ensp;在对投标项目的目标和范围都明确后，就可以开始搭建技术建议书的目录框架结构。注意有些技术标发出来本身就提供了技术建议书的目录结构要求，那么遵从甲方的要求就可以了，但是你还是可以在不破坏甲方目录结构的情况下在最后增加一个附录来编写你认为有必要说明的关键问题和公司技术亮点等。 &ensp; &ensp;如果技术标本身没有限定项目的目录结构，那么就需要我们自己搭建。那么首先我们来看对于软件类项目应标的时候技术建议书的一个通用大框架： 项目概述（包括项目背景，目标，项目建设范围等） 需求分析（重点是你对项目目标范围的理解，对关键建设内容逐个分析） 项目整体建设方案（总体架构，技术架构，功能架构-按建设范围逐层分解描述，部署方案，安全方案） 项目实施方案（实施方法论，团队组织，人员，进度计划等） 项目管理方案（标准项目管理方法论上修订） 项目案例说明（客户，项目规模，建设内容，实施周期，人员等） 下面我们以上内容的关键点做一个说明： &ensp; &ensp;项目概述的内容基本从甲方提供的标书材料里面拷贝，不用去加工。重点是需求分析部分，需要分析部门说明你对项目建设目标内容的理解，你大概准备采用什么产品，技术来实现需求等。需求分析是衔接项目建设目标范围和项目整体解决方案间的桥梁。否则给甲方看文档的感觉就是两者之间脱节，不清楚你是根据目标如果就给出了一个整体方案和架构，而这些都需要在需求分析部分说明清楚。 &ensp; &ensp;最难的还是项目整体建设方案章节，你需要拿出一个总体架构图，这个架构图覆盖本期项目建设范围，同时体现完整的逻辑和分层。然后对这个总架构图进行分解，即成了后续各个子系统建设方案的详细描述。这个地方如何进行抽象整合，如何揉是最难的点。 &ensp; &ensp;同时整体方案也包括了部署架构，非功能性架构（安全，性能，管控，部署和网络）各方面的内容，这些都需要在整体解决方案中进行详细描述。所以不要简单的以为整体解决方案仅仅是功能架构的描述。如果安装企业架构的思路，那么整体解决方案应该分为： &ensp; &ensp;总体架构描述（业务架构，应用架构，数据架构，集成架构，技术架构（非功能性架构全在这））,然后业务架构可以按流程线或业务域进行分解描述，应用架构按子系统分解展开详细描述。这样整体解决方案就形成了一个完整统一，紧凑的文档结构模式。 建议书内容编写分工，架构设计&ensp; &ensp;对于一个大项目的技术建议书编写，往往在搭建完整体目录结构后可以开始考虑进行内容分解，分解后安排到不同的人员去编写。比如不同的子系统方案安排到不同的人编写，对于标准和业务无关的技术方案安排到技术架构，对于IT基础设施和部署架构安排到工程人员编写。 &ensp; &ensp;对于这种大的技术建议书，统筹的人最重要，一个大的售前项目应标和技术建议书编写本身就是一个项目，需要有严格的项目计划和进度控制，啥时候完成哪部分的编写，啥时候整合，啥时候进行内容评审和修订，啥时候安排打印等都需要有明确的时间安排。否则很容易出现在交标前手忙脚乱的情况。 在内容编写的时候首先又要分出两部分内容： 哪些是原来建议书就写过的的标准化的内容，不用修改的? 哪些是需要根据本次应标项目有针对性的调整的? &ensp; &ensp;也正是这个原因，如果经常做售前项目应标，不是简单的积累已有的技术方案和技术建议书，而是应该对产品功能说明，项目管理方法论，团队人员简历，运维和售后规范流程，项目案例等都准备独立的可复用的标准化，模块化文件。到了真正应标的时候，根据需要对这些内容进行组装和整合。 &ensp; &ensp;而实际我们要做的，对于整体解决方案里面就是整体架构设计，通过整体架构设计图和内容说明将前面的需求分析和后面的模块化产品说明串接起来形成一个整体。其次，就是实施方面，这个涉及到需要根据项目本期的业务目标和需求排项目的项目进度计划，安排项目人员等，这些也需要花较多时间准备。 建议书内容整合和检查&ensp; &ensp;最后一个阶段就是对建议书内容进行整合，整合完成后进行目录结构，字体，行距，错别字等基础的合规性检查。其次是按照项目目标范围要求，进行内容的检查，确认没有关键内容遗漏。最后就是基于项目技术打分表，进一步确认每个技术打分项都在提交的技术建议书里面有明确的描述，同时完成技术评分指引表，说明具体的内容位置。 原文链接: https://steemit.com/it/@tigernotiger/beu5g作者: tigernotiger]]></content>
      <categories>
        <category>docs</category>
      </categories>
      <tags>
        <tag>docs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(一)hexo搭建]]></title>
    <url>%2Fhexo-build%2F</url>
    <content type="text"><![CDATA[nodeJs环境 安装node 从官网地址下载稳定版,并安装 环境配置 如果node -v 不显示版本号,则需要配置环境变量 配置全局环境变量 vim .bash_profile 1PATH=$PATH:/usr/local/bin/ 安装使用 npm 安装 Hexo。 1sudo npm install -g hexo-cli 使用cd到路径后1hexo init 建立hexo项目,即可开始使用]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[针对java8的Optional进行增强 (OptionalPlus)]]></title>
    <url>%2Fjava8-optional-plus%2F</url>
    <content type="text"><![CDATA[&ensp; &ensp; 网上关于optional用法的文章有一大堆了,但都只是简单的说了下如何去使用,感觉和实际使用中情况差的蛮大的.&ensp; &ensp; 在最初尝试使用optional的时候感觉很迷茫,感觉这个东西作用不大啊,看了遍源码也无法理解意义何在.&ensp; &ensp; 然后强迫自己多使用了几次后,发现这个功能还是挺好用的,也慢慢理解了作者的意图.&ensp; &ensp; 但随着使用次数增多,发现optional在很多场景下根本无法满足自己的需要,写了一半只能删掉用常规的写法.&ensp; &ensp; 所以为了满足自己的需求,写了OptionalPlus来治愈自己的强迫症 optional简洁 optional-plus不同场景示例 判断对象是否为空,为空执行A操作,不为空执行B操作12345678910111213141516171819public P2cMessageData example()&#123; P2cMessageData data = new P2cMessageData(); OptionalPlus.ofNullable(getTokenAndSessionByDeviceId(data.getDeviceId())) .filter(DebuggingDeviceTokenAndSessionData::getIsReady) .filter(deviceTokenAndSessionData -&gt; deviceTokenAndSessionData.getSessionInfo() != null) .ifNotPresent(() -&gt; &#123; logger.info("无密钥,尝试重新获取密钥!") data.setDecryptedData("无密钥,尝试重新获取密钥!"); ServerConnectGlobal.refreshTokenAndSession(data.getDeviceId()); &#125;) .ifPresent(deviceTokenAndSessionData -&gt; &#123; String sessionKey = deviceTokenAndSessionData.getSessionInfo().getSessionKey(); String devicePinCipher = deviceTokenAndSessionData.getSessionInfo().getDevicePinCipher(); data.setDecryptedData(AesUtils.decrypt(data.getMessage().getData(), sessionKey, devicePinCipher)); &#125;); return data;&#125; 完整代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public final class OptionalPlus&lt;T&gt; &#123; private final Optional&lt;T&gt; optional; private OptionalPlus(Optional&lt;T&gt; optional) &#123; this.optional = Objects.requireNonNull(optional); &#125; public static &lt;T&gt; OptionalPlus&lt;T&gt; empty() &#123; return new OptionalPlus&lt;&gt;(Optional.empty()); &#125; public static &lt;T&gt; OptionalPlus&lt;T&gt; of(T t) &#123; return new OptionalPlus&lt;&gt;(Optional.of(t)); &#125; public static &lt;T&gt; OptionalPlus&lt;T&gt; ofNullable(T t) &#123; return t == null ? empty() : of(t); &#125; public static &lt;T&gt; OptionalPlus&lt;T&gt; ofNullable(Optional&lt;T&gt; t) &#123; return t == null ? empty() : new OptionalPlus&lt;&gt;(t); &#125; /** * 获取optional对象,只保证optional不为null * * @return */ public Optional&lt;T&gt; getOptional() &#123; if (optional == null) &#123; throw new NoSuchElementException("No value present"); &#125; return optional; &#125; public T get() &#123; return getOptional().get(); &#125; public boolean isPresent() &#123; return optional.isPresent(); &#125; /** * 如果不为null,执行回调,并返回this * * @param consumer * @return */ public OptionalPlus&lt;T&gt; ifPresent(Consumer&lt;? super T&gt; consumer) &#123; optional.ifPresent(consumer); return this; &#125; public OptionalPlus&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) &#123; return optional.filter(predicate).isPresent() ? this : empty(); &#125; public &lt;U&gt; OptionalPlus&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) &#123; return OptionalPlus.ofNullable(optional.map(mapper)); &#125; public T orElse(T other) &#123; return optional.orElse(other); &#125; public T orElseGet(Supplier&lt;? extends T&gt; other) &#123; return optional.orElseGet(other); &#125; public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X &#123; return optional.orElseThrow(exceptionSupplier); &#125; /** * 如果对象为null,执行回调,并返回this * * @param noArgsFunction * @return */ public OptionalPlus&lt;T&gt; ifNotPresent(NoArgsFunction noArgsFunction) &#123; if (!isPresent()) &#123; noArgsFunction.todo(); &#125; return this; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) &#123; return true; &#125; if (!(obj instanceof OptionalPlus)) &#123; return false; &#125; OptionalPlus&lt;?&gt; other = (OptionalPlus&lt;?&gt;) obj; return Objects.equals(optional, other.getOptional()); &#125; @Override public int hashCode() &#123; return Objects.hashCode(optional); &#125; @Override public String toString() &#123; return optional != null ? optional.toString() : "Optional.empty"; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
        <tag>optional</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索seo等]]></title>
    <url>%2Fhexo-sitemap%2F</url>
    <content type="text"><![CDATA[收录确认网站是否被收录直接在百度/谷歌搜索 site:blog.zull.cn 提交网站未被收录,会出现提交地址,点击进入.这里用html验证就好了 下载验证html 根据提示,下载验证html,并保存到source根目录 有一个比较坑的地方,source下文件会被模板改变 所以需要再文件头上增加 123 ---layout: false--- 站点地图 插件12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 验证hexo g检查public目录下的sitemap.xml和baidusitemap.xml 部署seokeywordshttps://segmentfault.com/a/1190000007477815在博客根目录下找到_config.yml文件，在所示地方添加keywords: 关键字1,关键字2,关键字3…，采用英文逗号隔开，注意keywords与关键词之间的空格12345678# Sitetitle: 站点标题subtitle: 站点副标题description: 站点描述author: 站点作者language: zh-CNtimezone:keywords: 前端博客,JavaScript,html5,css3,Jquery,NodeJs,Ubuntu（#博客关键字）]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8常用新特性]]></title>
    <url>%2Fjava8-new-features%2F</url>
    <content type="text"><![CDATA[函数式编程-lambda 本质上是匿名函数 语法更简洁 12345678910// Java 8之前：new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("Before Java8, too much code for too little to do"); &#125;&#125;).start();//Java 8方式：new Thread( () -&gt; System.out.println("In Java8, Lambda expression rocks !!") ).start(); 格式 无返回值 1234(int params) -&gt; &#123;your Code&#125;// 一个参数的,可以不加小括号;代码块如果只有一行,大括号也不需要;参数类型不需要加params -&gt; your Code(params,params) -&gt; your Code 有返回值 123456params -&gt; your Code(params,params) -&gt; &#123; your Code; return xxx; &#125; 函数接口 常用接口 Function&lt;T, R&gt; Consumer Supplier Predicate FunctionalInterface注解 自定义接口 捕获外部变量 捕获实例或静态变量是没有限制的(可认为是通过 final 类型的局部变量 this 来引用前两者) 捕获的局部变量必须显式的声明为 final 或实际效果的的 final 类型(编译器推断变量的“常量性”（finality）) 例子见com.iflytek.vbox.skill.platform.service.VboxProvinceSkillManagementService#provinceManagement 集合中遍历、排序等 1234List&lt;String&gt; list = Arrays.asList("1", "2", "3", "4", "5", "6");list.listIterator().forEachRemaining(s -&gt; System.out.println(s));list.listIterator().forEachRemaining(System.out::println);list.forEach(System.out::println); 双冒号 检查异常 接口默认方法- 继承 - optional为了避免空指针异常,详见 OptionalPlus 简书例子]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo技巧]]></title>
    <url>%2Fhexo-skill%2F</url>
    <content type="text"><![CDATA[官方中文文档 介绍source文件下为markdown文章,其中 _drafts 为私密文章 _posts 为正常的文章 目录下可以自行建立文件夹 博客配置站点配置文件_config.yml 说明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137# Hexo Configuration Hexo配置文件## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# 网站信息#标题title: 那年四月#副标题subtitle: 小桥 · 流水 · 人家#网站描述description: 吃饭睡觉打豆豆(づ｡◕‿‿◕｡)づ#作者昵称author: 吃兔子的小萝卜#网站语言，设置简体汉语language: zh-Hans#时区，默认电脑时区#timezone: timezone: Asia/Shanghai# 网址设置#如果网站是放在子目录中，将url设置成'http://yoursite.com/child'，将root设置成'/child/'## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'#网址url: http://wangyiting.win#网站根目录。如果网站是放在子目录中，将root设置成'子目录名'root: /#文章链接地址格式 。即文章存放的目录。permalink: :year/:month/:day/:title/permalink_defaults:# 目录设置#资源文件夹，放在里面的文件会上传到github中source_dir: source#公共文件夹，存放生成的静态文件public_dir: public#标签文件夹，默认是tags。实际存放在source/tags中。tag_dir: tags#rss_dir: rss#档案文件夹，默认是archives。archive_dir: archives#分类文件夹，默认是categories。实际存放在source/categories中。category_dir: categories#代码文件夹，默认是downloads/codecode_dir: downloads/code#国际化文件夹，默认跟language相同i18n_dir: :lang#不需要渲染的文件夹或文件夹,放在[]中# 例如百度和google的站长验证文件，不能渲染，否则会改变内容，不能验证过skip_render: # 写作文章选项# 新建博文（帖子）的默认名称# File name of new postsnew_post_name: :title.md #默认布局模板是post，而不是draft和pagedefault_layout: post#是否将标题转换成标题形式（首字母大写）titlecase: false # Transform title into titlecase#在新标签页面中打开网页external_link: true # Open external links in new tabfilename_case: 0#是否渲染草稿render_drafts: false#启动 Asset 文件夹post_asset_folder: false#把链接改为与根目录的相对位址relative_link: false#显示未来的文章future: true#代码块的设置highlight: enable: true # 使用代码高亮 line_number: true # 显示行号 auto_detect: true # 自动检测语言 tab_replace:# 分类和标签# 默认分类default_category: uncategorized#分类别名category_map:#标签别名tag_map:# 日期和时间格式#Hexo 使用 Moment.js 来解析和显示时间。## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# 分页配置#每页显示的文章量 per_page: 8#分页路径，在public中可以看到#pagination_dir: page# Extensions 拓展插件配置## Plugins: https://hexo.io/plugins/plugins: baidusitemap: path: baidusitemap.xml#search 站内搜索# 需要安装插件：# npm install hexo-generator-search --save# npm install hexo-generator-searchdb --savesearch: path: search.xml field: post format: html limit: 10000# 主题配置## Themes: https://hexo.io/themes/#theme: false #禁用主题#theme: landscapetheme: next# Deployment 部署配置## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: # 部署到github，取消注释，可同时部署 # github: git@github.com:erbiduo/wyt.github.io.git,master # 部署到coding.net coding: git@git.coding.net:erduo/blog.git,master 新增私密文章1hexo new draft &quot;私密文章标题1&quot; 会在source/_drafts目录下生成md文件 如果你希望强行预览草稿，更改配置文件： render_drafts: true 或者，如下方式启动server： hexo server --drafts 预览的时候不全部显示所有内容md中加上&lt;!--more--&gt; 预览的时候会显示更多按钮 github绑定自己的域名注意: 需要再source文件下新增名为CNAME的文件,内容为域名]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
